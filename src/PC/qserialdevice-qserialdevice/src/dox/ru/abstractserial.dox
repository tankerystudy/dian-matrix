/*
* This file is part of QSerialDevice, an open-source cross-platform library
* Copyright (C) 2009  Denis Shienkov
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
* Contact Denis Shienkov:
*          e-mail: <scapig2@yandex.ru>
*             ICQ: 321789831
*/


/*! \~russian
    \class AbstractSerial

    \brief Класс AbstractSerial предоставляет интерфейс для работы с последовательными устройствами.

    Этот класс является кроссплатформенной библиотекой которая использует низкоуровневые API
    для доступа к последовательным устройствам.\n
    Класс использует фреймворк Qt4 и может использоваться для создания приложений Qt4.\n

    При реализации структуры класса AbstractSerial за базовую структуру была выбрана структура класса \b QAbstractSocket,
    т.е. структура класса AbstractSerial похожа на структуру класса \b QAbstractSocket и соответствует идеологии открытых/закрытых классов \b pimpl.\n

    Работа этого класса с последовательным устройством на \b низком уровне осуществляется в асинхронном режиме, т.е.:
    - Дескриптор устройства открывается в неблокирующем режиме.
    - Функции чтения и записи возвращают управление сразу не ожидая прихода символов/байт.
    - Структуры устройства отвечающие за ожидание символов "игнорируются".
    .
    
    Но при использовании \b обёрток (т.е. методов класса AbstractSerial) над низкоуровневыми API происходит 
    принудительное блокирование операций I/O, т.е.:
    - При вызове метода AbstractSerial::read() происходит чтение данных с ожиданием следующего символа и контролем 
    количества реально прочитанных байт.\n
    Поэтому метод возвращает управление \b после того как прочитает заданное количество байт!
    - При вызове метода AbstractSerial::write() происходит запись данных с ожиданием и контролем количества реально записанных байт.\n
    Поэтому метод возвращает управление \b после того как запишет заданное количество байт!
    .
    
    \note В связи с этими особенностями I/O (т.е. с тем что методы класса ожидают завершения асинхронных операций I/O) при 
    больших объемах данных передаваемых/принимаемых  через последовательное устройство с использованием GUI,
    возможны замирания(тормоза) GUI.
    Поэтому рекомендуется создавать объект класса AbstractSerial в другом потоке или использовать иные способы для обеспечения отзывчивости GUI.\n

    Начало работы с классом необходимо начинать с создания экземпляра объекта AbstractSerial.\n

    Пример:
    \code
        ..
        AbstractSerial *serialDevice = new AbstractSerial(this);
        ..
    \endcode

    При этом объект в зависимости от ОС получит имя соответствующего последовательного устройства из списка:

    \verbatim
        Операционная система:          Имя устройства по умолчанию:
        Windows                        "COM1"
        IRIX                           "/dev/ttyf1"
        HPUX                           "/dev/tty1p0"
        SOLARIS                        "/dev/ttya"
        FREEBSD                        "/dev/ttyd1"
        LINUX                          "/dev/ttyS0"
        <default>                      "/dev/ttyS0"
    \endverbatim

    Далее необходимо устройству(объекту) присвоить реально существующее имя в системе:
    - void AbstractSerial::setDeviceName(const QString &deviceName) устанавливает имя устройства.
    .
    \note для определения существующих имен устройств можно использовать класс SerialDeviceWatcher.

    Для открытия последовательного устройства необходимо вызвать метод:
    - bool AbstractSerial::open(OpenMode mode) открывает устройство.
    \note Устройство всегда открывается в монопольном режиме поэтому другие процессы не смогут получить доступ к этому устройству.

    Класс AbstractSerial поддерживает только эти опции открытия: AbstractSerial::OpenMode.\n
    Пример:
    \code
        ..
        //this example open device as ReadOnly
        bool ret = serialDevice->open(AbstractSerial::ReadOnly);
        ..
    \endcode

    Для закрытия последовательного устройства необходимо вызвать метод:
    - void AbstractSerial::close() закрывает последовательное устройство.
    .

    После того как устройство успешно открыто можно приступать к его конфигурированию.\n
    Для конфигурирования необходимо воспользоваться следующими методами:
    - bool AbstractSerial::setBaudRate(AbstractSerial::BaudRate) устанавливает скорость обмена.
    \sa setInputBaudRate(AbstractSerial::BaudRate baudRate), setOutputBaudRate(AbstractSerial::BaudRate baudRate)
    - bool AbstractSerial::setDataBits(AbstractSerial::DataBits) устанавливает количество бит данных.
    - bool AbstractSerial::setParity(AbstractSerial::Parity) устанавливает контроль четности.
    - bool AbstractSerial::setStopBits(AbstractSerial::StopBits) устанавливает количество стоп бит.
    - bool AbstractSerial::setFlowControl(AbstractSerial::Flow) устанавливает контроль управления потоком.
    - bool AbstractSerial::setCharIntervalTimeout(int msecs) устанавливает время ожидания символа при чтении данных.
    \note Для уверенного чтения данных необходимо опытным путем подобрать таймаут \a msecs и 
    обычно достаточно значения \a 10ms для всех скоростей.
    Данный метод упрощает настройку последовательного устройства.

    .

    Для получения текущей конфигурации устройства используются методы:
    - QString AbstractSerial::baudRate() const возвращает понятное для человека значение скорости.
    \sa inputBaudRate() const, outputBaudRate() const
    - QString AbstractSerial::dataBits() const возвращает понятное для человека кол-во бит данных.
    - QString AbstractSerial::parity() const возвращает понятное для человека значение паритета.
    - QString AbstractSerial::stopBits() const возвращает понятное для человека кол-во стоп-бит.
    - QString AbstractSerial::flowControl() const возвращает понятное для человека значение управления потоком.
    - int AbstractSerial::charIntervalTimeout() const возвращает понятное для человека значение времени ожидания символа.
    .

    Для получения списков поддерживаемых классом параметров используются методы:
    - QStringList AbstractSerial::listBaudRate() const возвращает понятный для человека список скоростей.
    - QStringList AbstractSerial::listDataBits() const возвращает понятный для человека список бит данных.
    - QStringList AbstractSerial::listParity() const возвращает понятный для человека список паритетов.
    - QStringList AbstractSerial::listStopBits() const возвращает понятный для человека список стоп-бит.
    - QStringList AbstractSerial::listFlowControl() const возвращает понятный для человека список управления потоком.
    .

    Для чтения данных из порта можно использовать любой метод из:
    - qint64 AbstractSerial::read(char *data, qint64 maxSize).
    - QByteArray AbstractSerial::read(qint64 maxSize).
    - QByteArray AbstractSerial::readAll().
    .

    \note При реализации этих методов акцент ставился на минимизацию потерь данных при чтении.
    Теоретически размер принимаемых данных ограничен только \a qint64 или \a QByteArray.

    Для записи данных в порт можно использовать любой метод из:
    - qint64 AbstractSerial::write(const char *data, qint64 maxSize).
    - qint64 AbstractSerial::write(const char *data).
    - qint64 AbstractSerial::write(const QByteArray &byteArray).
    .

    \note Теоретически размер записываемых данных ограничен только \a qint64 или \a QByteArray.

    Для ожидания прихода данных в последовательное устройство используется метод:
    - bool AbstractSerial::waitForReadyRead(int msecs) ожидает в течении времени msecs прихода в приемный буфер
    последовательного устройства хотя бы одного байта данных.
    .

    Для очистки буферов последовательного устройства используются методы:
    - bool AbstractSerial::flush() ожидает завершения операций I/O и по их окончании
    очищает очереди I/O.
    - bool AbstractSerial::reset() не ожидает завершения операций I/O и очищает буферы последовательного
    устройства.
    .

    Для управления RS-232 линиями DTR и RTS используются методы:
    - bool AbstractSerial::setDtr(bool set) устанавливает/сбрасывает линию DTR.
    - bool AbstractSerial::setRts(bool set) устанавливает/сбрасывает линию RTS.

    Для получения статусов RS-232 линий CTS, DSR, DCD, RI, RTS, DTR, ST, SR используется метод:
    - quint16 AbstractSerial::lineStatus() возвращает закодированные значения статусов линий побитовым \b ИЛИ
    (см. enum AbstractSerial::LineStatus).

    \verbatim
        LE    = 0x0001 - Line DSR (data set ready/line enable).
        DTR   = 0x0002 - Line DTR (data terminal ready).
        RTS   = 0x0004 - Line RTS (request to send).
        ST    = 0x0008 - Line Secondary TXD (transmit).
        SR    = 0x0010 - Line Secondary RXD (receive.)
        CTS   = 0x0020 - Line CTS (clear to send).
        DCD   = 0x0040 - Line DCD (data carrier detect).
        RI    = 0x0080 - Line RNG (ring).
        DSR   = 0x0100 - Line DSR (data set ready).

        Err   = 0x8000 - Error get line status.
    \endverbatim
    .
    
    Для управления разрывами линии Tx используются методы:
    - bool AbstractSerial::sendBreak(int duration) передает в Tx поток нулевых битов в течении определенного времени.
    - bool AbstractSerial::setBreak(bool set) включает/отключает передачу в Tx нулевых битов.
    .

    Для получения текущего количества байт в приемном буфере последовательного устройства готовых для чтения
    используется метод:
    - qint64 AbstractSerial::bytesAvailable() получает текущее количество байт в приемном буфере.
    .

    Для включения/отключения режима излучения сигнала signalStatus() используется метод:
    - void AbstractSerial::enableEmitStatus(bool enable). 
    .

    Класс AbstractSerial реализует следующие сигналы:
    - void AbstractSerial::readyRead() излучается \a ОДИН раз при приходе в приемный буфер устройства
    хотя бы одного байта данных. Событие о приходе данных контролируется в цикле сообщений.
    Если приходит следующая часть данных (или один байт) то сигнал повторно не излучается.
    Для того чтобы сигнал снова излучился необходимо прочитать из буфера данные или сбросить буфер.
    Также этот сигнал излучается каждый раз при успешном вызове метода waitForReadyRead().
    - void AbstractSerial::bytesWritten(qint64 bytes) излучается при успешном завершении метода записи данных.
    - void AbstractSerial::signalStatus(const QString &status, QDateTime current) несёт информацию о текущем статусе
    последовательного устройства, а также времени и дате возникновения статуса.\n
    Этот сигнал излучается:
        - При выполнении методов открытия или закрытия устройства.
        - При ошибках при конфигурировании устройства.
        - При ошибках I/O устройства.
        .
    
    Излучение сигнала можно включать/отключать методом: AbstractSerial::enableEmitStatus(bool enable).
    .

    \n
    \n
    \n

    \warning В этой аннотации приведены только основные методы для работы с классом (т.е. не все), поэтому
    ознакомьтесь с полным перечнем методов самостоятельно! 

    \author Денис Шиенков \n
    Контакты:
    - ICQ       : 321789831
    - e-mail    : scapig2@yandex.ru
*/

//----------------------------------------------------------------------------------------------------------------------------------------

//Open modes

/*! \~russian
    \enum AbstractSerial::OpenMode
    Режимы открытия последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::OpenMode AbstractSerial::NotOpen
    Не открыто.
*/

/*! \~russian
    \var AbstractSerial::OpenMode AbstractSerial::ReadOnly
    Открыто только для чтения.
*/

/*! \~russian
    \var AbstractSerial::OpenMode AbstractSerial::WriteOnly
    Открыто только для записи.
*/

/*! \~russian
    \var AbstractSerial::OpenMode AbstractSerial::ReadWrite
    Открыто и для чтения и для записи.
*/

//Speeds

/*! \~russian
    \enum AbstractSerial::BaudRate
    Стандартные типы скоростей последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRateUndefined
    Скорость неопределена.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate50
    Скорость 50 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate75
    Скорость 75 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate110
    Скорость 110 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate134
    Скорость 134 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate150
    Скорость 150 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate200
    Скорость 200 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate300
    Скорость 300 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate600
    Скорость 600 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate1200
    Скорость 1200 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate1800
    Скорость 1800 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate2400
    Скорость 2400 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate4800
    Скорость 4800 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate9600
    Скорость 9600 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate14400
    Скорость 14400 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate19200
    Скорость 19200 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate38400
    Скорость 38400 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate56000
    Скорость 5600 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate57600
    Скорость 57600 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate76800
    Скорость 76800 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate115200
    Скорость 115200 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate128000
    Скорость 128000 бод.
*/

/*! \~russian
    \var AbstractSerial::BaudRate AbstractSerial::BaudRate256000
    Скорость 256000 бод.
*/

//Data bits

/*! \~russian
    \enum AbstractSerial::DataBits
    Стандартные типы бит данных последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::DataBitsUndefined
    Биты данных неопределены.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::DataBits5
    5 бит данных.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::DataBits6
    6 бит данных.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::DataBits7
    7 бит данных.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::DataBits8
    8 бит данных.
*/

//Parity

/*! \~russian
    \enum AbstractSerial::Parity
    Стандартные типы паритета последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParityUndefined
    Паритет неопределен.
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParityNone
    Паритет "нет".
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParityOdd
    Паритет "нечет".
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParityEven
    Паритет "чет".
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParityMark
    Паритет "маркер".
*/

/*! \~russian
    \var AbstractSerial::DataBits AbstractSerial::ParitySpace
    Паритет "пробел".
*/

//Stop bits

/*! \~russian
    \enum AbstractSerial::StopBits
    Стандартные типы стоповых бит последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::StopBits AbstractSerial::StopBitsUndefined
    Кол-во стоповых бит неопределено.
*/

/*! \~russian
    \var AbstractSerial::StopBits AbstractSerial::StopBits1
    Один стоповый бит.
*/

/*! \~russian
    \var AbstractSerial::StopBits AbstractSerial::StopBits1_5
    Полтора стоповых бита.
*/

/*! \~russian
    \var AbstractSerial::StopBits AbstractSerial::StopBits2
    Два стовопых бита.
*/

//Flows

/*! \~russian
    \enum AbstractSerial::Flow
    Стандартные типы управления потоком последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::Flow AbstractSerial::FlowControlUndefined
    Управление потоком неопределено.
*/

/*! \~russian
    \var AbstractSerial::Flow AbstractSerial::FlowControlOff
    Управление потоком отключено.
*/

/*! \~russian
    \var AbstractSerial::Flow AbstractSerial::FlowControlHardware
    Управление потоком аппаратное.
*/

/*! \~russian
    \var AbstractSerial::Flow AbstractSerial::FlowControlXonXoff
    Управление потоком Xon/Xoff.
*/

//Statuses

/*! \~russian
    \enum AbstractSerial::Status
    Статусы последовательного устройства которые поддерживает класс AbstractSerial.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENone
    Нет ошибок.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneOpen
    Успешно открыто.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneClose
    Успешно закрыто.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetBaudRate
    Тип скорости успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetParity
    Тип паритета успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetDataBits
    Тип бит данных успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetStopBits
    Тип стоповых бит успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetFlow
    Тип контроля потока успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetCharTimeout
    Таймаут ожидания символа успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetDtr
    DTR успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneSetRts
    RTS успешно изменен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ENoneLineStatus
    Статусы линий успешно получены.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpen
    Ошибка открытия.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EDeviceIsNotOpen
    Еще не открыто.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenModeUnsupported
    Режим открытия не поддерживается.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenModeUndefined
    Режим открытия неопределен.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenInvalidFD
    Недостоверный дескриптор.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenOldSettingsNotSaved
    Ошибка сохранения старых параметров при открытии.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenGetCurrentSettings
    Ошибка получения текущих параметров при открытии.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EOpenSetDefaultSettings
    Ошибка изменения параметров по умолчанию при открытии.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EDeviceIsOpen
    Уже открыто.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ECloseSetOldSettings
    Ошибка сохранения старых параметров при закрытии.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ECloseFD
    Ошибка закрытия дескриптора.
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EClose
    Ошибка закрытия. 
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetBaudRate
    Ошибка изменения типа скорости.          
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetDataBits
    Ошибка изменения типа бит данных.     
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetParity
    Ошибка изменения типа паритета.     
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetStopBits
    Ошибка изменения типа стоповых бит.     
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetFlowControl
    Ошибка изменения типа управления потоком.     
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetCharIntervalTimeout
    Ошибка изменения таймаута ожидания символа.     
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EBytesAvailable
    Ошибка получения из буфера количества байт готовых для чтения.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetDtr
    Ошибка изменения DTR.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetRts
    Ошибка изменения RTS. 
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ELineStatus
    Ошибка получения статусов линий. 
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EWaitReadyReadIO
    Ошибка I/O ожидания приема данных.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EWaitReadyReadTimeout
    Таймаут ожидания приема данных.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EWaitReadyWriteIO
    Ошибка I/O ожидания передачи данных.    
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EWaitReadyWriteTimeout
    Таймаут ожидания передачи данных.    
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EReadDataIO
    Ошибка чтения данных.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EWriteDataIO
    Ошибка передачи данных.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::EFlush
    Ошибка очистки очереди передачи буфера.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESendBreak
    Ошибка передачи непрерывного потока нулевых бит.  
*/

/*! \~russian
    \var AbstractSerial::Status AbstractSerial::ESetBreak
    Ошибка изменения сигнала разрыва линии.  
*/

//Line statuses

/*! \~russian
    \enum AbstractSerial::LineStatus
    Флаги состояний линий: CTS, DSR, DCD, RI, RTS, DTR, ST, SR интерфейса последовательного устройства (см. стандарт RS-232 и т.п.).\n
    Для определения состояния желаемой линии необходимо наложить маску "И" соответствующего флага линии на 
    результат выполнения метода: ulong AbstractSerial::lineStatus().
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsCTS
    Линия CTS.
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsDSR
    Линия DSR.
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsDCD
    Линия DCD.
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsRI
    Линия RI. 
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsRTS
    Линия RTS. 
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsDTR
    Линия DTR. 
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsST
    Линия ST. 
*/

/*! \~russian
    \var AbstractSerial::LineStatus AbstractSerial::lsSR
    Линия SR. 
*/

//----------------------------------------------------------------------------------------------------------------------------------------

/*! \~russian
    \fn AbstractSerial::AbstractSerial(QObject *parent)
    Конструктор по умолчанию.\n Устройству присваивается имя из списка:
    \verbatim
        Operating system:       Name DEFAULT_DEVICE_NAME:
        Windows                 "COM1"
        IRIX                    "/dev/ttyf1"
        HPUX                    "/dev/tty1p0"
        SOLARIS                 "/dev/ttya"
        FREEBSD                 "/dev/ttyd1"
        LINUX                   "/dev/ttyS0"
        <default>               "/dev/ttyS0"
    \endverbatim
*/

/*! \~russian 
    \fn AbstractSerial::~AbstractSerial()
    Деструктор по умолчанию.
*/

/*! \~russian 
    \fn void AbstractSerial::setDeviceName(const QString &deviceName)
    Присваивает созданному объекту имя последовательного устройства \a deviceName.
    Работает только если устройство еще не открыто, иначе игнорируется!
    \param[in] deviceName Имя последовательного устройства реально существующего в системе и 
    которое хотим установить.\n
    Например: для Windows это: COM1, COM2 .. COMn, для Linux это: /dev/ttyS0, /dev/ttyS1 и т.д.
*/

/*! \~russian 
    \fn QString AbstractSerial::deviceName() const
    Возвращает имя текущего последовательного устройства с которым сконфигурирован объект.
    \return Имя в виде QString.
*/

/*! \~russian
    \fn void AbstractSerial::setOpenMode(OpenMode mode)
    Устанавливает режим открытия \a mode последовательного устройства.
    Работает только если устройство еще не открыто, иначе игнорируется!
    \param[in] mode Режим открытия ( см. AbstractSerial::OpenMode ).
*/

/*! \~russian 
    \fn AbstractSerial::OpenMode AbstractSerial::openMode() const
    Возвращает текущий режим открытия последовательного устройства.
    \return Режим открытия ( см. AbstractSerial::OpenMode ).
*/

/*! \~russian
    \fn bool AbstractSerial::open(OpenMode mode)
    Открывает последовательное устройство в режиме \a mode.
    Работает только если устройство еще не открыто, иначе игнорируется! 
    \param[in] mode Режим с которым хотим открыть последовательное устройство ( см. AbstractSerial::OpenMode ).
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::isOpen() const
    Возвращает статус последовательного устройства: открыто/закрыто.
    \return \a True если устройство открыто.
*/

/*! \~russian
    \fn void AbstractSerial::close()
    Закрывает последовательное устройство которое уже было открыто, иначе игнорируется.
*/

/*! \~russian
    \fn bool AbstractSerial::setBaudRate(BaudRate baudRate)
    Устанавливает для последовательного устройства скорость \a baudRate:
    - В Windows этот метод устанавливает только один тип скорости.
    - В *.nix этот метод устанавливает входящую и исходящую скорости одинаковыми.
    .
    \param[in] baudRate Желаемая скорость последовательного устройства ( см. AbstractSerial::BaudRate ).
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::setInputBaudRate(BaudRate baudRate)
    Устанавливает для последовательного устройства только входящую скорость \a baudRate.
    В Windows этот метод всегда возвращает \a false т.к. независимая входящая скорость не поддерживается.
    \param[in] baudRate Желаемая входящая скорость последовательного устройства ( см. AbstractSerial::BaudRate ).
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::setOutputBaudRate(BaudRate baudRate)
    Устанавливает для последовательного устройства только исходящую скорость \a baudRate.
    В Windows этот метод всегда возвращает \a false т.к. независимая исходящая скорость не поддерживается.
    \param[in] baudRate Желаемая исходящая скорость последовательного устройства ( см. AbstractSerial::BaudRate ).
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::setBaudRate(const QString &baudRate)
    \overload
    \n Устанавливает для последовательного устройства скорость в бодах \a baudRate:
    - В Windows этот метод устанавливает только один тип скорости.
    - В *.nix этот метод устанавливает входящую и исходящую скорости одинаковыми.
    .
    \param[in] baudRate Желаемая скорость последовательного устройства в виде QString.
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::setInputBaudRate(const QString &baudRate)
    \overload
    \n Устанавливает для последовательного устройства только входящую скорость \a baudRate.
    В Windows этот метод всегда возвращает \a false т.к. независимая входящая скорость не поддерживается.
    \param[in] baudRate Желаемая входящая скорость последовательного устройства в виде QString.
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn bool AbstractSerial::setOutputBaudRate(const QString &baudRate)
    \overload
    \n Устанавливает для последовательного устройства только исходящую скорость \a baudRate.
    В Windows этот метод всегда возвращает \a false т.к. независимая исходящая скорость не поддерживается.
    \param[in] baudRate Желаемая исходящая скорость последовательного устройства в виде QString.
    \return \a False в случае ошибки.
*/

/*! \~russian 
    \fn QString AbstractSerial::baudRate() const
    Возвращает текущую скорость с которой сконфигурировано последовательное устройство.
    \return Cкорость в виде QString.
*/

/*! \~russian 
    \fn QString AbstractSerial::inputBaudRate() const
    Возвращает текущую входящую скорость с которой сконфигурировано последовательное устройство.
    \return Cкорость в виде QString.
*/

/*! \~russian
    \fn QString AbstractSerial::outputBaudRate() const
    Возвращает текущую исходящую скорость с которой сконфигурировано последовательное устройство.
    \return Cкорость в виде QString.
*/

/*! \~russian
    \fn QStringList AbstractSerial::listBaudRate() const
    Возвращает текстовый список всех скоростей поддерживаемых классом AbstractSerial.
    \return Cписок скоростей в виде QStringList.
*/

/*! \~russian
    \fn QMap<AbstractSerial::BaudRate, QString> AbstractSerial::baudRateMap() const
    Возвращает мапу всех скоростей поддерживаемых классом Abstractserial. Используется для заполнения QComboBox.
    \return Мапа скоростей в виде QMap<AbstractSerial::BaudRate, QString>.
*/

/*! \~russian
    \fn bool AbstractSerial::setDataBits(DataBits dataBits)
    Устанавливает для последовательного устройства количество бит данных \a dataBits.
    \param[in] dataBits Желаемое количество бит данных последовательного устройства ( см. AbstractSerial::DataBits ).
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setDataBits(const QString &dataBits)
    \overload
    \n Устанавливает для последовательного устройства количество бит данных \a dataBits.
    \param[in] dataBits Желаемое количество бит данных последовательного устройства в виде QString.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn QString AbstractSerial::dataBits() const
    Возвращает текущее количество бит данных с которыми сконфигурировано последовательное устройство.
    \return Количество бит данных в виде QString.
*/

/*! \~russian
    \fn QStringList AbstractSerial::listDataBits() const
    Возвращает текстовый список всех типов бит данных. поддерживаемых классом AbstractSerial.
    \return Cписок бит данных в виде QStringList.
*/

/*! \~russian
    \fn QMap<AbstractSerial::DataBits, QString> AbstractSerial::dataBitsMap() const
    Возвращает мапу всех видов бит данных поддерживаемых классом AbstractSerial. Используется для заполнения QComboBox.
    \return Мапа типов бит данных в виде QMap<AbstractSerial::DataBits, QString>.
*/

/*! \~russian
    \fn bool AbstractSerial::setParity(Parity parity)
    Устанавливает для последовательного устройства тип контроля четности \a parity.
    \param[in] parity Желаемый тип контроля четности последовательного устройства ( см. AbstractSerial::Parity ).
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setParity(const QString &parity)
    \overload
    \n Устанавливает для последовательного устройства тип контроля четности \a parity.
    \param[in] parity Желаемый тип контроля четности последовательного устройства в виде QString. 
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn QString AbstractSerial::parity() const
    Возвращает текущий тип контроля четности с которым сконфигурировано последовательное устройство.
    \return Тип контроля четности в виде QString.
*/

/*! \~russian
    \fn QStringList AbstractSerial::listParity() const
    Возвращает текстовый список всех типов контроля паритета поддерживаемых классом AbstractSerial.
    \return Cписок типов контроля паритета в виде QStringList.
*/

/*! \~russian
    \fn QMap<AbstractSerial::Parity, QString> AbstractSerial::parityMap() const
    Возвращает мапу всех видов паритета поддерживаемых классом AbstractSerial. Используется для заполнения QComboBox.
    \return Мапа типов паритета в виде QMap<AbstractSerial::Parity, QString>.
*/

/*! \~russian
    \fn bool AbstractSerial::setStopBits(StopBits stopBits)
    Устанавливает для последовательного устройства количество стоп-бит \a stopBits.
    \param[in] stopBits Желаемое количество стоп-бит последовательного устройства ( см. AbstractSerial::StopBits ).
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setStopBits(const QString &stopBits)
    \overload
    \n Устанавливает для последовательного устройства количество стоп-бит \a stopBits.
    \param[in] stopBits Желаемое количество стоп-бит последовательного устройства в виде QString. 
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn QString AbstractSerial::stopBits() const
    Возвращает текущее количество стоп-бит с которым сконфигурировано последовательное устройство.
    \return Количество стоп-бит в виде QString.
*/

/*! \~russian
    \fn QStringList AbstractSerial::listStopBits() const
    Возвращает текстовый список всех типов стоп-бит поддерживаемых классом AbstractSerial.
    \return Cписок стоп-бит в виде QStringList.
*/

/*! \~russian
    \fn QMap<AbstractSerial::StopBits, QString> AbstractSerial::stopBitsMap() const
    Возвращает мапу всех видов стоп бит поддерживаемых классом AbstractSerial. Используется для заполнения QComboBox.
    \return Мапа типов стоп-бит в виде QMap<AbstractSerial::StopBits, QString>.
*/

/*! \~russian
    \fn bool AbstractSerial::setFlowControl(Flow flow)
    Устанавливает для последовательного устройства режим управления потоком \a flow.
    \param[in] flow Желаемый тип управления потоком последовательного устройства ( см. AbstractSerial::Flow ).
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setFlowControl(const QString &flow)
    \overload
    \n Устанавливает для последовательного устройства режим управления потоком \a flow.
    \param[in] flow Желаемый тип управления потоком последовательного устройства в виде QString.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn QString AbstractSerial::flowControl() const
    Возвращает текущий режим управления потоком с которым сконфигурировано последовательное устройство.
    \return Режим управления потоком в виде QString.
*/

/*! \~russian
    \fn QStringList AbstractSerial::listFlowControl() const
    Возвращает текстовый список всех режимов управления потоком поддерживаемых классом AbstractSerial.
    \return Cписок режимов управления потоком в виде QStringList.
*/

/*! \~russian
    \fn QMap<AbstractSerial::Flow, QString> AbstractSerial::flowControlMap() const
    Возвращает мапу всех видов контроля потока поддерживаемых классом AbstractSerial. Используется для заполнения QComboBox.
    \return Мапа типов контроля потока в виде QMap<AbstractSerial::Flow, QString>.
*/

/*! \~russian
    \fn bool AbstractSerial::setCharIntervalTimeout(int msecs)
    Устанавливает время ожидания прихода символа в приемный буфер последовательного устройства.
    \param[in] msecs Желаемое время ожидания прихода символа, в мсек.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn int AbstractSerial::charIntervalTimeout() const
    Возвращает текущее время ожидания прихода символа в приемный буфер последовательного устройства с которым оно сконфигурировано.
    \return Время ожидания прихода символа, в мсек.
*/

/*! \~russian
    \fn bool AbstractSerial::setDtr(bool set)
    Устанавливает линию DTR в состояное "high" или "low" в зависимости от параметра \a set.
    \param[in] set Желаемое состояние линии DTR.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setRts(bool set)
    Устанавливает линию RTS в состояное "high" или "low" в зависимости от параметра \a set.
    \param[in] set Желаемое состояние линии RTS.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn ulong AbstractSerial::lineStatus()
    Возвращает статусы линий CTS, DSR, DCD, RI, RTS, DTR, ST, SR.
    Метод возвращает закодированные значения статусов линий побитовым ИЛИ.
    \return Закодированное побитно значение в виде ulong.
*/

/*! \~russian
    \fn bool AbstractSerial::sendBreak(int duration)
    Передает непрерывный поток нулевых битов в течение указанного промежутка времени \a duration
    если терминал использует асинхронную последовательность передачи данных.\n
    Значение \a duration :
    - Если \a duration == 0 то нулевые биты передаются по меньшей мере в течение 0.25 секунд, но не более 0.5 секунды.
    - Если \a duration != 0 то нулевые биты передаются в течении некоторого периода времени зависящего от реализации.
    .
    \param[in] duration Промежуток времени, в мсек.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::setBreak(bool set)
    Включает/отключает сигнал разрыва, 
    т.е. начинает/прекращает отправлять нулевые биты в зависимости от параметра \a set :
    - Eсли \a set == true то включить передачу.
    - Eсли \a set == false то отключить передачу.
    .
    \param[in] set Флаг включения/отключения передачи нулевых битов.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::flush()
    Очищает буферы последовательного устройства после завершения операций I/O.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::reset()
    Сбрасывает буферы последовательного устройства.
    \return \a False в случае ошибки.
*/

/*! \~russian
    \fn qint64 AbstractSerial::bytesAvailable() const
    Возвращает количество байт готовых для чтения которые находятся во входном буфере последовательного устройства.
    \return Количество байт доступных байт или -1 В случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::waitForReadyRead(int msecs)
    Ожидает прихода во входной буфер последовательного устройства хотя-бы одного байта данных в течении времени \a msecs.
    При успешном выполнении (т.е. если дождались символ) излучается сигнал readyRead().
    \param[in] msecs Время в течении которого ожидается приход символа, в мсек.
    \return \a False в случае ошибки или при таймауте.
*/

/*! \~russian
    \fn bool AbstractSerial::waitForBytesWritten(int msecs)
    Ожидает ухода из выходного буфера последовательного устройства последнего символа в течении времени \a msecs.
    \note В данной версии библиотеки этот метод пока не реализован!
*/

/*! \~russian
    \fn void AbstractSerial::enableEmitStatus(bool enable)
    Включает/отключает режим испускания сигнала signalStatus() в зависимости от параметра \a enable :
    - Если \a enable == true то включить испускание сигнала signalStatus().
    - Если \a enable == false то отключить испускание сигнала signalStatus().
    \param[in] enable Режим.
*/

/*! \~russian
    \fn qint64 AbstractSerial::read(char *data, qint64 maxSize)
    Читает из последовательного устройства \a maxSize байт данных в буфер \a data.
    \param[out] data Указатель на массив (буфер) в который будут прочитаны данные.
    \param[in] maxSize Длина данных которые хотим прочитать.
    \return Количество реально прочитанных байт или -1 в случае ошибки.
*/

/*! \~russian
    \fn QByteArray AbstractSerial::read(qint64 maxSize)
    \overload
    \n Читает из последовательного устройства \a maxSize байт данных и 
    возвращает результат в виде QByteArray.\n
    Этот метод не сообщает об ошибках, т.е. если метод возвратил пустой QByteArray 
    то это значит что была ошибка или нет данных для чтения.
    \return Массив данных в виде QByteArray.
*/

/*! \~russian
    \fn QByteArray AbstractSerial::readAll()
    \overload
    \n Читает из последовательного устройства все доступные данные и возвращает 
    результат в виде QByteArray.\n
    Этот метод не сообщает об ошибках, т.е. если метод возвратил пустой QByteArray 
    то это значит что была ошибка или нет данных для чтения.
    \return Массив данных в виде QByteArray.
*/

/*! \~russian
    \fn qint64 AbstractSerial::write(const char *data, qint64 maxSize)
    Записывает в последовательное устройство \a maxSize байт данных из буфера \a data.
    \param[in] data Указатель на массив (буфер) из которого будут записаны данные.
    \param[in] maxSize Длина данных которые хотим записать.
    \return Количество реально записанных байт или -1 в случае ошибки.
*/

/*! \~russian
    \fn qint64 AbstractSerial::write(const char *data)
    \overload
    \n Записывает в последовательное устройство данные в виде нуль-терминированной
    строки 8-битных символов из буфера \a data. \n
    Это эквивалентно:
    \code
    ...
    AbstractSerial::write(data, qstrlen(data));
    ...
    \endcode
    \param[in] data Указатель на буфер из которого будут записаны данные.
    \return Количество реально записанных байт или -1 в случае ошибки.
*/

/*! \~russian
    \fn qint64 AbstractSerial::write(const QByteArray &byteArray)
    \overload
    \n Записывает в последовательное устройство содержимое \a byteArray.
    \return Количество реально записанных байт или -1 в случае ошибки.
*/

/*! \~russian
    \fn bool AbstractSerial::canEmitStatusString() const
    Возвращает значение флага который определяет испускать или нет сигнал signalStatus().
    \return Значение флага:
    - Если \a true то испускание сигнала signalStatus() включено.
    - Если \a false то испускание сигнала signalStatus() отключено.
*/

/*! \~russian
    \fn bool AbstractSerial::isValid() const
*/

/*! \~russian
    \fn void AbstractSerial::readyRead()
    Этот сигнал испускается один раз при приходе в приемный буфер последовательного устройства
    хотя бы одного байта. Т.е. если вы сделали "connect" к этому сигналу после того как
    в приемный буфер последовательного устройства пришли данные то ваш слот не отработает т.к.
    сигнал уже излучился. Поэтому "connect" желательно делать перед тем как вы открываете порт!
    Для того чтобы сигнал снова испустился необходимо прочесть данные из последовательного устройства
    или сбросить(очистить) буфер последовательного устройства.\n

    Пример:
    \code
    //constructor
    MyClass::MyClass(QObject *parent)
    {
        ..
        port = new AbstractSerial(this);
        ..
        //here set device name
        ..
        //< here to do "connect" is recommended (before the opening)
        connect( port, SIGNAL(readyRead()), this, SLOT(readDataSlot()) );
        ..

        //here open port
        port->open(mode);

        //< here to do "connect" is not recommended (after the opening)
        ..
        //here configure port
        ..
     }

     //slot
     void MyClass::readDataSlot()
     {
        ..
        QByteArray data = port->readAll();
        ..
     }
    \endcode
*/

/*! \~russian
    \fn void AbstractSerial::bytesWritten(qint64 bytes)
    Этот сигнал испускается каджый раз при успешной записи данных в последовательное устройство.
    \param[out] bytes Кол-во байт которые записали реально в последовательное устройство.
*/

/*! \~russian
    \fn void AbstractSerial::signalStatus(const QString &status, QDateTime current)
    Этот сигнал автоматически испускается при изменении статуса AbstractSerial. \n
    Изменение статуса может быть вызвано следующими причинами:
    - При ошибках конфигурировании устройства.
    - При его открытии/закрытии.
    - При ошибках I/O.
    .
    \param[out] status Текущий статус последовательного устройства.
    \param[out] current Текущее значение даты/времени изменения статуса.
    
    Пример:
    \code
    //constructor
    MyClass::MyClass(QObject *parent)
    {
        ..
        port = new AbstractSerial(this);
        ..
        connect( port, SIGNAL(signalStatus(const QString &, QDateTime)), this, SLOT(viewStateSlot(QString &, QDateTime)) );
        ..
        //here set device name
        ..
        //here open port
        ..
        //here configure port
        ..
     }

     //slot
     void MyClass::viewStateSlot(QString &stateMsg, QDateTime dt)
     {
        ..
        qDebug() << "State: " << stateMsg << ", in time: " << dt.time().toString();
        ..
     }
    \endcode
*/
